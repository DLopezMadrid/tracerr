// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scene_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scene_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>// IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/port_undef.inc>
#include <google/protobuf/repeated_field.h>// IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scene_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
  class AnyMetadata;
}// namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scene_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scene_2eproto;
namespace tracerr {
  class Scene;
  class SceneDefaultTypeInternal;
  extern SceneDefaultTypeInternal _Scene_default_instance_;
  class Scene_Light;
  class Scene_LightDefaultTypeInternal;
  extern Scene_LightDefaultTypeInternal _Scene_Light_default_instance_;
  class Scene_Obj;
  class Scene_ObjDefaultTypeInternal;
  extern Scene_ObjDefaultTypeInternal _Scene_Obj_default_instance_;
  class Scene_Pos;
  class Scene_PosDefaultTypeInternal;
  extern Scene_PosDefaultTypeInternal _Scene_Pos_default_instance_;
  class Scene_Rectangle;
  class Scene_RectangleDefaultTypeInternal;
  extern Scene_RectangleDefaultTypeInternal _Scene_Rectangle_default_instance_;
  class Scene_Sphere;
  class Scene_SphereDefaultTypeInternal;
  extern Scene_SphereDefaultTypeInternal _Scene_Sphere_default_instance_;
  class Scene_Triangle;
  class Scene_TriangleDefaultTypeInternal;
  extern Scene_TriangleDefaultTypeInternal _Scene_Triangle_default_instance_;
}// namespace tracerr
PROTOBUF_NAMESPACE_OPEN
template<>
::tracerr::Scene *Arena::CreateMaybeMessage<::tracerr::Scene>(Arena *);
template<>
::tracerr::Scene_Light *Arena::CreateMaybeMessage<::tracerr::Scene_Light>(Arena *);
template<>
::tracerr::Scene_Obj *Arena::CreateMaybeMessage<::tracerr::Scene_Obj>(Arena *);
template<>
::tracerr::Scene_Pos *Arena::CreateMaybeMessage<::tracerr::Scene_Pos>(Arena *);
template<>
::tracerr::Scene_Rectangle *Arena::CreateMaybeMessage<::tracerr::Scene_Rectangle>(Arena *);
template<>
::tracerr::Scene_Sphere *Arena::CreateMaybeMessage<::tracerr::Scene_Sphere>(Arena *);
template<>
::tracerr::Scene_Triangle *Arena::CreateMaybeMessage<::tracerr::Scene_Triangle>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace tracerr {

  enum Scene_ShapeType : int {
    Scene_ShapeType_tSphere = 0,
    Scene_ShapeType_tTriangle = 1,
    Scene_ShapeType_tRectangle = 2
  };
  bool Scene_ShapeType_IsValid(int value);
  constexpr Scene_ShapeType Scene_ShapeType_ShapeType_MIN = Scene_ShapeType_tSphere;
  constexpr Scene_ShapeType Scene_ShapeType_ShapeType_MAX = Scene_ShapeType_tRectangle;
  constexpr int Scene_ShapeType_ShapeType_ARRAYSIZE = Scene_ShapeType_ShapeType_MAX + 1;

  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *Scene_ShapeType_descriptor();
  template<typename T>
  inline const std::string &Scene_ShapeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Scene_ShapeType>::value ||
                          ::std::is_integral<T>::value,
                  "Incorrect type passed to function Scene_ShapeType_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            Scene_ShapeType_descriptor(), enum_t_value);
  }
  inline bool Scene_ShapeType_Parse(
          const std::string &name, Scene_ShapeType *value) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Scene_ShapeType>(
            Scene_ShapeType_descriptor(), name, value);
  }
  // ===================================================================

  class Scene_Pos PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracerr.Scene.Pos) */ {
public:
    inline Scene_Pos() : Scene_Pos(nullptr){};
    virtual ~Scene_Pos();

    Scene_Pos(const Scene_Pos &from);
    Scene_Pos(Scene_Pos &&from) noexcept
        : Scene_Pos() {
      *this = ::std::move(from);
    }

    inline Scene_Pos &operator=(const Scene_Pos &from) {
      CopyFrom(from);
      return *this;
    }
    inline Scene_Pos &operator=(Scene_Pos &&from) noexcept {
      if (GetArena() == from.GetArena()) {
        if (this != &from) InternalSwap(&from);
      } else {
        CopyFrom(from);
      }
      return *this;
    }

    inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet &unknown_fields() const {
      return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
    }
    inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet *mutable_unknown_fields() {
      return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
      return GetDescriptor();
    }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
      return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
      return GetMetadataStatic().reflection;
    }
    static const Scene_Pos &default_instance();

    static void InitAsDefaultInstance();// FOR INTERNAL USE ONLY
    static inline const Scene_Pos *internal_default_instance() {
      return reinterpret_cast<const Scene_Pos *>(
              &_Scene_Pos_default_instance_);
    }
    static constexpr int kIndexInFileMessages =
            0;

    friend void swap(Scene_Pos &a, Scene_Pos &b) {
      a.Swap(&b);
    }
    inline void Swap(Scene_Pos *other) {
      if (other == this) return;
      if (GetArena() == other->GetArena()) {
        InternalSwap(other);
      } else {
        ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
    }
    void UnsafeArenaSwap(Scene_Pos *other) {
      if (other == this) return;
      GOOGLE_DCHECK(GetArena() == other->GetArena());
      InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline Scene_Pos *New() const final {
      return CreateMaybeMessage<Scene_Pos>(nullptr);
    }

    Scene_Pos *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
      return CreateMaybeMessage<Scene_Pos>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void CopyFrom(const Scene_Pos &from);
    void MergeFrom(const Scene_Pos &from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8 *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Scene_Pos *other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
      return "tracerr.Scene.Pos";
    }

protected:
    explicit Scene_Pos(::PROTOBUF_NAMESPACE_ID::Arena *arena);

private:
    static void ArenaDtor(void *object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
      ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
      return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
      kXFieldNumber = 1,
      kYFieldNumber = 2,
      kZFieldNumber = 3,
    };
    // required float x = 1;
    bool has_x() const;

private:
    bool _internal_has_x() const;

public:
    void clear_x();
    float x() const;
    void set_x(float value);

private:
    float _internal_x() const;
    void _internal_set_x(float value);

public:
    // required float y = 2;
    bool has_y() const;

private:
    bool _internal_has_y() const;

public:
    void clear_y();
    float y() const;
    void set_y(float value);

private:
    float _internal_y() const;
    void _internal_set_y(float value);

public:
    // required float z = 3;
    bool has_z() const;

private:
    bool _internal_has_z() const;

public:
    void clear_z();
    float z() const;
    void set_z(float value);

private:
    float _internal_z() const;
    void _internal_set_z(float value);

public:
    // @@protoc_insertion_point(class_scope:tracerr.Scene.Pos)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template<typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    friend struct ::TableStruct_scene_2eproto;
  };
  // -------------------------------------------------------------------

  class Scene_Light PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracerr.Scene.Light) */ {
public:
    inline Scene_Light() : Scene_Light(nullptr){};
    virtual ~Scene_Light();

    Scene_Light(const Scene_Light &from);
    Scene_Light(Scene_Light &&from) noexcept
        : Scene_Light() {
      *this = ::std::move(from);
    }

    inline Scene_Light &operator=(const Scene_Light &from) {
      CopyFrom(from);
      return *this;
    }
    inline Scene_Light &operator=(Scene_Light &&from) noexcept {
      if (GetArena() == from.GetArena()) {
        if (this != &from) InternalSwap(&from);
      } else {
        CopyFrom(from);
      }
      return *this;
    }

    inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet &unknown_fields() const {
      return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
    }
    inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet *mutable_unknown_fields() {
      return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
      return GetDescriptor();
    }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
      return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
      return GetMetadataStatic().reflection;
    }
    static const Scene_Light &default_instance();

    static void InitAsDefaultInstance();// FOR INTERNAL USE ONLY
    static inline const Scene_Light *internal_default_instance() {
      return reinterpret_cast<const Scene_Light *>(
              &_Scene_Light_default_instance_);
    }
    static constexpr int kIndexInFileMessages =
            1;

    friend void swap(Scene_Light &a, Scene_Light &b) {
      a.Swap(&b);
    }
    inline void Swap(Scene_Light *other) {
      if (other == this) return;
      if (GetArena() == other->GetArena()) {
        InternalSwap(other);
      } else {
        ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
    }
    void UnsafeArenaSwap(Scene_Light *other) {
      if (other == this) return;
      GOOGLE_DCHECK(GetArena() == other->GetArena());
      InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline Scene_Light *New() const final {
      return CreateMaybeMessage<Scene_Light>(nullptr);
    }

    Scene_Light *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
      return CreateMaybeMessage<Scene_Light>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void CopyFrom(const Scene_Light &from);
    void MergeFrom(const Scene_Light &from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8 *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Scene_Light *other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
      return "tracerr.Scene.Light";
    }

protected:
    explicit Scene_Light(::PROTOBUF_NAMESPACE_ID::Arena *arena);

private:
    static void ArenaDtor(void *object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
      ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
      return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
      kPFieldNumber = 1,
      kIntensityFieldNumber = 2,
    };
    // required .tracerr.Scene.Pos p = 1;
    bool has_p() const;

private:
    bool _internal_has_p() const;

public:
    void clear_p();
    const ::tracerr::Scene_Pos &p() const;
    ::tracerr::Scene_Pos *release_p();
    ::tracerr::Scene_Pos *mutable_p();
    void set_allocated_p(::tracerr::Scene_Pos *p);

private:
    const ::tracerr::Scene_Pos &_internal_p() const;
    ::tracerr::Scene_Pos *_internal_mutable_p();

public:
    void unsafe_arena_set_allocated_p(
            ::tracerr::Scene_Pos *p);
    ::tracerr::Scene_Pos *unsafe_arena_release_p();

    // required float intensity = 2;
    bool has_intensity() const;

private:
    bool _internal_has_intensity() const;

public:
    void clear_intensity();
    float intensity() const;
    void set_intensity(float value);

private:
    float _internal_intensity() const;
    void _internal_set_intensity(float value);

public:
    // @@protoc_insertion_point(class_scope:tracerr.Scene.Light)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template<typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::tracerr::Scene_Pos *p_;
    float intensity_;
    friend struct ::TableStruct_scene_2eproto;
  };
  // -------------------------------------------------------------------

  class Scene_Sphere PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracerr.Scene.Sphere) */ {
public:
    inline Scene_Sphere() : Scene_Sphere(nullptr){};
    virtual ~Scene_Sphere();

    Scene_Sphere(const Scene_Sphere &from);
    Scene_Sphere(Scene_Sphere &&from) noexcept
        : Scene_Sphere() {
      *this = ::std::move(from);
    }

    inline Scene_Sphere &operator=(const Scene_Sphere &from) {
      CopyFrom(from);
      return *this;
    }
    inline Scene_Sphere &operator=(Scene_Sphere &&from) noexcept {
      if (GetArena() == from.GetArena()) {
        if (this != &from) InternalSwap(&from);
      } else {
        CopyFrom(from);
      }
      return *this;
    }

    inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet &unknown_fields() const {
      return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
    }
    inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet *mutable_unknown_fields() {
      return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
      return GetDescriptor();
    }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
      return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
      return GetMetadataStatic().reflection;
    }
    static const Scene_Sphere &default_instance();

    static void InitAsDefaultInstance();// FOR INTERNAL USE ONLY
    static inline const Scene_Sphere *internal_default_instance() {
      return reinterpret_cast<const Scene_Sphere *>(
              &_Scene_Sphere_default_instance_);
    }
    static constexpr int kIndexInFileMessages =
            2;

    friend void swap(Scene_Sphere &a, Scene_Sphere &b) {
      a.Swap(&b);
    }
    inline void Swap(Scene_Sphere *other) {
      if (other == this) return;
      if (GetArena() == other->GetArena()) {
        InternalSwap(other);
      } else {
        ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
    }
    void UnsafeArenaSwap(Scene_Sphere *other) {
      if (other == this) return;
      GOOGLE_DCHECK(GetArena() == other->GetArena());
      InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline Scene_Sphere *New() const final {
      return CreateMaybeMessage<Scene_Sphere>(nullptr);
    }

    Scene_Sphere *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
      return CreateMaybeMessage<Scene_Sphere>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void CopyFrom(const Scene_Sphere &from);
    void MergeFrom(const Scene_Sphere &from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8 *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Scene_Sphere *other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
      return "tracerr.Scene.Sphere";
    }

protected:
    explicit Scene_Sphere(::PROTOBUF_NAMESPACE_ID::Arena *arena);

private:
    static void ArenaDtor(void *object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
      ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
      return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
      kMaterialFieldNumber = 3,
      kPFieldNumber = 1,
      kRadiusFieldNumber = 2,
    };
    // required string material = 3;
    bool has_material() const;

private:
    bool _internal_has_material() const;

public:
    void clear_material();
    const std::string &material() const;
    void set_material(const std::string &value);
    void set_material(std::string &&value);
    void set_material(const char *value);
    void set_material(const char *value, size_t size);
    std::string *mutable_material();
    std::string *release_material();
    void set_allocated_material(std::string *material);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string *unsafe_arena_release_material();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_material(
            std::string *material);

private:
    const std::string &_internal_material() const;
    void _internal_set_material(const std::string &value);
    std::string *_internal_mutable_material();

public:
    // required .tracerr.Scene.Pos p = 1;
    bool has_p() const;

private:
    bool _internal_has_p() const;

public:
    void clear_p();
    const ::tracerr::Scene_Pos &p() const;
    ::tracerr::Scene_Pos *release_p();
    ::tracerr::Scene_Pos *mutable_p();
    void set_allocated_p(::tracerr::Scene_Pos *p);

private:
    const ::tracerr::Scene_Pos &_internal_p() const;
    ::tracerr::Scene_Pos *_internal_mutable_p();

public:
    void unsafe_arena_set_allocated_p(
            ::tracerr::Scene_Pos *p);
    ::tracerr::Scene_Pos *unsafe_arena_release_p();

    // required float radius = 2;
    bool has_radius() const;

private:
    bool _internal_has_radius() const;

public:
    void clear_radius();
    float radius() const;
    void set_radius(float value);

private:
    float _internal_radius() const;
    void _internal_set_radius(float value);

public:
    // @@protoc_insertion_point(class_scope:tracerr.Scene.Sphere)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template<typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr material_;
    ::tracerr::Scene_Pos *p_;
    float radius_;
    friend struct ::TableStruct_scene_2eproto;
  };
  // -------------------------------------------------------------------

  class Scene_Triangle PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracerr.Scene.Triangle) */ {
public:
    inline Scene_Triangle() : Scene_Triangle(nullptr){};
    virtual ~Scene_Triangle();

    Scene_Triangle(const Scene_Triangle &from);
    Scene_Triangle(Scene_Triangle &&from) noexcept
        : Scene_Triangle() {
      *this = ::std::move(from);
    }

    inline Scene_Triangle &operator=(const Scene_Triangle &from) {
      CopyFrom(from);
      return *this;
    }
    inline Scene_Triangle &operator=(Scene_Triangle &&from) noexcept {
      if (GetArena() == from.GetArena()) {
        if (this != &from) InternalSwap(&from);
      } else {
        CopyFrom(from);
      }
      return *this;
    }

    inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet &unknown_fields() const {
      return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
    }
    inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet *mutable_unknown_fields() {
      return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
      return GetDescriptor();
    }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
      return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
      return GetMetadataStatic().reflection;
    }
    static const Scene_Triangle &default_instance();

    static void InitAsDefaultInstance();// FOR INTERNAL USE ONLY
    static inline const Scene_Triangle *internal_default_instance() {
      return reinterpret_cast<const Scene_Triangle *>(
              &_Scene_Triangle_default_instance_);
    }
    static constexpr int kIndexInFileMessages =
            3;

    friend void swap(Scene_Triangle &a, Scene_Triangle &b) {
      a.Swap(&b);
    }
    inline void Swap(Scene_Triangle *other) {
      if (other == this) return;
      if (GetArena() == other->GetArena()) {
        InternalSwap(other);
      } else {
        ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
    }
    void UnsafeArenaSwap(Scene_Triangle *other) {
      if (other == this) return;
      GOOGLE_DCHECK(GetArena() == other->GetArena());
      InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline Scene_Triangle *New() const final {
      return CreateMaybeMessage<Scene_Triangle>(nullptr);
    }

    Scene_Triangle *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
      return CreateMaybeMessage<Scene_Triangle>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void CopyFrom(const Scene_Triangle &from);
    void MergeFrom(const Scene_Triangle &from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8 *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Scene_Triangle *other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
      return "tracerr.Scene.Triangle";
    }

protected:
    explicit Scene_Triangle(::PROTOBUF_NAMESPACE_ID::Arena *arena);

private:
    static void ArenaDtor(void *object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
      ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
      return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
      kMaterialFieldNumber = 4,
      kP0FieldNumber = 1,
      kP1FieldNumber = 2,
      kP2FieldNumber = 3,
    };
    // required string material = 4;
    bool has_material() const;

private:
    bool _internal_has_material() const;

public:
    void clear_material();
    const std::string &material() const;
    void set_material(const std::string &value);
    void set_material(std::string &&value);
    void set_material(const char *value);
    void set_material(const char *value, size_t size);
    std::string *mutable_material();
    std::string *release_material();
    void set_allocated_material(std::string *material);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string *unsafe_arena_release_material();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_material(
            std::string *material);

private:
    const std::string &_internal_material() const;
    void _internal_set_material(const std::string &value);
    std::string *_internal_mutable_material();

public:
    // required .tracerr.Scene.Pos p0 = 1;
    bool has_p0() const;

private:
    bool _internal_has_p0() const;

public:
    void clear_p0();
    const ::tracerr::Scene_Pos &p0() const;
    ::tracerr::Scene_Pos *release_p0();
    ::tracerr::Scene_Pos *mutable_p0();
    void set_allocated_p0(::tracerr::Scene_Pos *p0);

private:
    const ::tracerr::Scene_Pos &_internal_p0() const;
    ::tracerr::Scene_Pos *_internal_mutable_p0();

public:
    void unsafe_arena_set_allocated_p0(
            ::tracerr::Scene_Pos *p0);
    ::tracerr::Scene_Pos *unsafe_arena_release_p0();

    // required .tracerr.Scene.Pos p1 = 2;
    bool has_p1() const;

private:
    bool _internal_has_p1() const;

public:
    void clear_p1();
    const ::tracerr::Scene_Pos &p1() const;
    ::tracerr::Scene_Pos *release_p1();
    ::tracerr::Scene_Pos *mutable_p1();
    void set_allocated_p1(::tracerr::Scene_Pos *p1);

private:
    const ::tracerr::Scene_Pos &_internal_p1() const;
    ::tracerr::Scene_Pos *_internal_mutable_p1();

public:
    void unsafe_arena_set_allocated_p1(
            ::tracerr::Scene_Pos *p1);
    ::tracerr::Scene_Pos *unsafe_arena_release_p1();

    // required .tracerr.Scene.Pos p2 = 3;
    bool has_p2() const;

private:
    bool _internal_has_p2() const;

public:
    void clear_p2();
    const ::tracerr::Scene_Pos &p2() const;
    ::tracerr::Scene_Pos *release_p2();
    ::tracerr::Scene_Pos *mutable_p2();
    void set_allocated_p2(::tracerr::Scene_Pos *p2);

private:
    const ::tracerr::Scene_Pos &_internal_p2() const;
    ::tracerr::Scene_Pos *_internal_mutable_p2();

public:
    void unsafe_arena_set_allocated_p2(
            ::tracerr::Scene_Pos *p2);
    ::tracerr::Scene_Pos *unsafe_arena_release_p2();

    // @@protoc_insertion_point(class_scope:tracerr.Scene.Triangle)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template<typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr material_;
    ::tracerr::Scene_Pos *p0_;
    ::tracerr::Scene_Pos *p1_;
    ::tracerr::Scene_Pos *p2_;
    friend struct ::TableStruct_scene_2eproto;
  };
  // -------------------------------------------------------------------

  class Scene_Rectangle PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracerr.Scene.Rectangle) */ {
public:
    inline Scene_Rectangle() : Scene_Rectangle(nullptr){};
    virtual ~Scene_Rectangle();

    Scene_Rectangle(const Scene_Rectangle &from);
    Scene_Rectangle(Scene_Rectangle &&from) noexcept
        : Scene_Rectangle() {
      *this = ::std::move(from);
    }

    inline Scene_Rectangle &operator=(const Scene_Rectangle &from) {
      CopyFrom(from);
      return *this;
    }
    inline Scene_Rectangle &operator=(Scene_Rectangle &&from) noexcept {
      if (GetArena() == from.GetArena()) {
        if (this != &from) InternalSwap(&from);
      } else {
        CopyFrom(from);
      }
      return *this;
    }

    inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet &unknown_fields() const {
      return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
    }
    inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet *mutable_unknown_fields() {
      return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
      return GetDescriptor();
    }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
      return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
      return GetMetadataStatic().reflection;
    }
    static const Scene_Rectangle &default_instance();

    static void InitAsDefaultInstance();// FOR INTERNAL USE ONLY
    static inline const Scene_Rectangle *internal_default_instance() {
      return reinterpret_cast<const Scene_Rectangle *>(
              &_Scene_Rectangle_default_instance_);
    }
    static constexpr int kIndexInFileMessages =
            4;

    friend void swap(Scene_Rectangle &a, Scene_Rectangle &b) {
      a.Swap(&b);
    }
    inline void Swap(Scene_Rectangle *other) {
      if (other == this) return;
      if (GetArena() == other->GetArena()) {
        InternalSwap(other);
      } else {
        ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
    }
    void UnsafeArenaSwap(Scene_Rectangle *other) {
      if (other == this) return;
      GOOGLE_DCHECK(GetArena() == other->GetArena());
      InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline Scene_Rectangle *New() const final {
      return CreateMaybeMessage<Scene_Rectangle>(nullptr);
    }

    Scene_Rectangle *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
      return CreateMaybeMessage<Scene_Rectangle>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void CopyFrom(const Scene_Rectangle &from);
    void MergeFrom(const Scene_Rectangle &from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8 *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Scene_Rectangle *other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
      return "tracerr.Scene.Rectangle";
    }

protected:
    explicit Scene_Rectangle(::PROTOBUF_NAMESPACE_ID::Arena *arena);

private:
    static void ArenaDtor(void *object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
      ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
      return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
      kMaterialFieldNumber = 5,
      kP0FieldNumber = 1,
      kP1FieldNumber = 2,
      kP2FieldNumber = 3,
      kP3FieldNumber = 4,
    };
    // required string material = 5;
    bool has_material() const;

private:
    bool _internal_has_material() const;

public:
    void clear_material();
    const std::string &material() const;
    void set_material(const std::string &value);
    void set_material(std::string &&value);
    void set_material(const char *value);
    void set_material(const char *value, size_t size);
    std::string *mutable_material();
    std::string *release_material();
    void set_allocated_material(std::string *material);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string *unsafe_arena_release_material();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_material(
            std::string *material);

private:
    const std::string &_internal_material() const;
    void _internal_set_material(const std::string &value);
    std::string *_internal_mutable_material();

public:
    // required .tracerr.Scene.Pos p0 = 1;
    bool has_p0() const;

private:
    bool _internal_has_p0() const;

public:
    void clear_p0();
    const ::tracerr::Scene_Pos &p0() const;
    ::tracerr::Scene_Pos *release_p0();
    ::tracerr::Scene_Pos *mutable_p0();
    void set_allocated_p0(::tracerr::Scene_Pos *p0);

private:
    const ::tracerr::Scene_Pos &_internal_p0() const;
    ::tracerr::Scene_Pos *_internal_mutable_p0();

public:
    void unsafe_arena_set_allocated_p0(
            ::tracerr::Scene_Pos *p0);
    ::tracerr::Scene_Pos *unsafe_arena_release_p0();

    // required .tracerr.Scene.Pos p1 = 2;
    bool has_p1() const;

private:
    bool _internal_has_p1() const;

public:
    void clear_p1();
    const ::tracerr::Scene_Pos &p1() const;
    ::tracerr::Scene_Pos *release_p1();
    ::tracerr::Scene_Pos *mutable_p1();
    void set_allocated_p1(::tracerr::Scene_Pos *p1);

private:
    const ::tracerr::Scene_Pos &_internal_p1() const;
    ::tracerr::Scene_Pos *_internal_mutable_p1();

public:
    void unsafe_arena_set_allocated_p1(
            ::tracerr::Scene_Pos *p1);
    ::tracerr::Scene_Pos *unsafe_arena_release_p1();

    // required .tracerr.Scene.Pos p2 = 3;
    bool has_p2() const;

private:
    bool _internal_has_p2() const;

public:
    void clear_p2();
    const ::tracerr::Scene_Pos &p2() const;
    ::tracerr::Scene_Pos *release_p2();
    ::tracerr::Scene_Pos *mutable_p2();
    void set_allocated_p2(::tracerr::Scene_Pos *p2);

private:
    const ::tracerr::Scene_Pos &_internal_p2() const;
    ::tracerr::Scene_Pos *_internal_mutable_p2();

public:
    void unsafe_arena_set_allocated_p2(
            ::tracerr::Scene_Pos *p2);
    ::tracerr::Scene_Pos *unsafe_arena_release_p2();

    // required .tracerr.Scene.Pos p3 = 4;
    bool has_p3() const;

private:
    bool _internal_has_p3() const;

public:
    void clear_p3();
    const ::tracerr::Scene_Pos &p3() const;
    ::tracerr::Scene_Pos *release_p3();
    ::tracerr::Scene_Pos *mutable_p3();
    void set_allocated_p3(::tracerr::Scene_Pos *p3);

private:
    const ::tracerr::Scene_Pos &_internal_p3() const;
    ::tracerr::Scene_Pos *_internal_mutable_p3();

public:
    void unsafe_arena_set_allocated_p3(
            ::tracerr::Scene_Pos *p3);
    ::tracerr::Scene_Pos *unsafe_arena_release_p3();

    // @@protoc_insertion_point(class_scope:tracerr.Scene.Rectangle)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template<typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr material_;
    ::tracerr::Scene_Pos *p0_;
    ::tracerr::Scene_Pos *p1_;
    ::tracerr::Scene_Pos *p2_;
    ::tracerr::Scene_Pos *p3_;
    friend struct ::TableStruct_scene_2eproto;
  };
  // -------------------------------------------------------------------

  class Scene_Obj PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracerr.Scene.Obj) */ {
public:
    inline Scene_Obj() : Scene_Obj(nullptr){};
    virtual ~Scene_Obj();

    Scene_Obj(const Scene_Obj &from);
    Scene_Obj(Scene_Obj &&from) noexcept
        : Scene_Obj() {
      *this = ::std::move(from);
    }

    inline Scene_Obj &operator=(const Scene_Obj &from) {
      CopyFrom(from);
      return *this;
    }
    inline Scene_Obj &operator=(Scene_Obj &&from) noexcept {
      if (GetArena() == from.GetArena()) {
        if (this != &from) InternalSwap(&from);
      } else {
        CopyFrom(from);
      }
      return *this;
    }

    inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet &unknown_fields() const {
      return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
    }
    inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet *mutable_unknown_fields() {
      return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
      return GetDescriptor();
    }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
      return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
      return GetMetadataStatic().reflection;
    }
    static const Scene_Obj &default_instance();

    static void InitAsDefaultInstance();// FOR INTERNAL USE ONLY
    static inline const Scene_Obj *internal_default_instance() {
      return reinterpret_cast<const Scene_Obj *>(
              &_Scene_Obj_default_instance_);
    }
    static constexpr int kIndexInFileMessages =
            5;

    friend void swap(Scene_Obj &a, Scene_Obj &b) {
      a.Swap(&b);
    }
    inline void Swap(Scene_Obj *other) {
      if (other == this) return;
      if (GetArena() == other->GetArena()) {
        InternalSwap(other);
      } else {
        ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
    }
    void UnsafeArenaSwap(Scene_Obj *other) {
      if (other == this) return;
      GOOGLE_DCHECK(GetArena() == other->GetArena());
      InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline Scene_Obj *New() const final {
      return CreateMaybeMessage<Scene_Obj>(nullptr);
    }

    Scene_Obj *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
      return CreateMaybeMessage<Scene_Obj>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void CopyFrom(const Scene_Obj &from);
    void MergeFrom(const Scene_Obj &from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8 *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Scene_Obj *other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
      return "tracerr.Scene.Obj";
    }

protected:
    explicit Scene_Obj(::PROTOBUF_NAMESPACE_ID::Arena *arena);

private:
    static void ArenaDtor(void *object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
      ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
      return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
      kFnameFieldNumber = 1,
      kMaterialFieldNumber = 2,
      kTranslationFieldNumber = 3,
    };
    // required string fname = 1;
    bool has_fname() const;

private:
    bool _internal_has_fname() const;

public:
    void clear_fname();
    const std::string &fname() const;
    void set_fname(const std::string &value);
    void set_fname(std::string &&value);
    void set_fname(const char *value);
    void set_fname(const char *value, size_t size);
    std::string *mutable_fname();
    std::string *release_fname();
    void set_allocated_fname(std::string *fname);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string *unsafe_arena_release_fname();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_fname(
            std::string *fname);

private:
    const std::string &_internal_fname() const;
    void _internal_set_fname(const std::string &value);
    std::string *_internal_mutable_fname();

public:
    // required string material = 2;
    bool has_material() const;

private:
    bool _internal_has_material() const;

public:
    void clear_material();
    const std::string &material() const;
    void set_material(const std::string &value);
    void set_material(std::string &&value);
    void set_material(const char *value);
    void set_material(const char *value, size_t size);
    std::string *mutable_material();
    std::string *release_material();
    void set_allocated_material(std::string *material);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string *unsafe_arena_release_material();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_material(
            std::string *material);

private:
    const std::string &_internal_material() const;
    void _internal_set_material(const std::string &value);
    std::string *_internal_mutable_material();

public:
    // optional .tracerr.Scene.Pos translation = 3;
    bool has_translation() const;

private:
    bool _internal_has_translation() const;

public:
    void clear_translation();
    const ::tracerr::Scene_Pos &translation() const;
    ::tracerr::Scene_Pos *release_translation();
    ::tracerr::Scene_Pos *mutable_translation();
    void set_allocated_translation(::tracerr::Scene_Pos *translation);

private:
    const ::tracerr::Scene_Pos &_internal_translation() const;
    ::tracerr::Scene_Pos *_internal_mutable_translation();

public:
    void unsafe_arena_set_allocated_translation(
            ::tracerr::Scene_Pos *translation);
    ::tracerr::Scene_Pos *unsafe_arena_release_translation();

    // @@protoc_insertion_point(class_scope:tracerr.Scene.Obj)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template<typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr material_;
    ::tracerr::Scene_Pos *translation_;
    friend struct ::TableStruct_scene_2eproto;
  };
  // -------------------------------------------------------------------

  class Scene PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracerr.Scene) */ {
public:
    inline Scene() : Scene(nullptr){};
    virtual ~Scene();

    Scene(const Scene &from);
    Scene(Scene &&from) noexcept
        : Scene() {
      *this = ::std::move(from);
    }

    inline Scene &operator=(const Scene &from) {
      CopyFrom(from);
      return *this;
    }
    inline Scene &operator=(Scene &&from) noexcept {
      if (GetArena() == from.GetArena()) {
        if (this != &from) InternalSwap(&from);
      } else {
        CopyFrom(from);
      }
      return *this;
    }

    inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet &unknown_fields() const {
      return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
    }
    inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet *mutable_unknown_fields() {
      return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
      return GetDescriptor();
    }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
      return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
      return GetMetadataStatic().reflection;
    }
    static const Scene &default_instance();

    static void InitAsDefaultInstance();// FOR INTERNAL USE ONLY
    static inline const Scene *internal_default_instance() {
      return reinterpret_cast<const Scene *>(
              &_Scene_default_instance_);
    }
    static constexpr int kIndexInFileMessages =
            6;

    friend void swap(Scene &a, Scene &b) {
      a.Swap(&b);
    }
    inline void Swap(Scene *other) {
      if (other == this) return;
      if (GetArena() == other->GetArena()) {
        InternalSwap(other);
      } else {
        ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
    }
    void UnsafeArenaSwap(Scene *other) {
      if (other == this) return;
      GOOGLE_DCHECK(GetArena() == other->GetArena());
      InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline Scene *New() const final {
      return CreateMaybeMessage<Scene>(nullptr);
    }

    Scene *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
      return CreateMaybeMessage<Scene>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
    void CopyFrom(const Scene &from);
    void MergeFrom(const Scene &from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8 *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Scene *other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
      return "tracerr.Scene";
    }

protected:
    explicit Scene(::PROTOBUF_NAMESPACE_ID::Arena *arena);

private:
    static void ArenaDtor(void *object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
      ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
      return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    typedef Scene_Pos Pos;
    typedef Scene_Light Light;
    typedef Scene_Sphere Sphere;
    typedef Scene_Triangle Triangle;
    typedef Scene_Rectangle Rectangle;
    typedef Scene_Obj Obj;

    typedef Scene_ShapeType ShapeType;
    static constexpr ShapeType tSphere =
            Scene_ShapeType_tSphere;
    static constexpr ShapeType tTriangle =
            Scene_ShapeType_tTriangle;
    static constexpr ShapeType tRectangle =
            Scene_ShapeType_tRectangle;
    static inline bool ShapeType_IsValid(int value) {
      return Scene_ShapeType_IsValid(value);
    }
    static constexpr ShapeType ShapeType_MIN =
            Scene_ShapeType_ShapeType_MIN;
    static constexpr ShapeType ShapeType_MAX =
            Scene_ShapeType_ShapeType_MAX;
    static constexpr int ShapeType_ARRAYSIZE =
            Scene_ShapeType_ShapeType_ARRAYSIZE;
    static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *
    ShapeType_descriptor() {
      return Scene_ShapeType_descriptor();
    }
    template<typename T>
    static inline const std::string &ShapeType_Name(T enum_t_value) {
      static_assert(::std::is_same<T, ShapeType>::value ||
                            ::std::is_integral<T>::value,
                    "Incorrect type passed to function ShapeType_Name.");
      return Scene_ShapeType_Name(enum_t_value);
    }
    static inline bool ShapeType_Parse(const std::string &name,
                                       ShapeType *value) {
      return Scene_ShapeType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
      kLightFieldNumber = 6,
      kSphereFieldNumber = 7,
      kTriangleFieldNumber = 8,
      kRectangleFieldNumber = 9,
      kObjFieldNumber = 10,
      kFnameFieldNumber = 4,
      kWidthFieldNumber = 1,
      kHeightFieldNumber = 2,
      kSaveFileFieldNumber = 3,
      kMultiThreadFieldNumber = 5,
      kShowElapsedTimeFieldNumber = 11,
    };
    // repeated .tracerr.Scene.Light light = 6;
    int light_size() const;

private:
    int _internal_light_size() const;

public:
    void clear_light();
    ::tracerr::Scene_Light *mutable_light(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Light> *
    mutable_light();

private:
    const ::tracerr::Scene_Light &_internal_light(int index) const;
    ::tracerr::Scene_Light *_internal_add_light();

public:
    const ::tracerr::Scene_Light &light(int index) const;
    ::tracerr::Scene_Light *add_light();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Light> &
    light() const;

    // repeated .tracerr.Scene.Sphere sphere = 7;
    int sphere_size() const;

private:
    int _internal_sphere_size() const;

public:
    void clear_sphere();
    ::tracerr::Scene_Sphere *mutable_sphere(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Sphere> *
    mutable_sphere();

private:
    const ::tracerr::Scene_Sphere &_internal_sphere(int index) const;
    ::tracerr::Scene_Sphere *_internal_add_sphere();

public:
    const ::tracerr::Scene_Sphere &sphere(int index) const;
    ::tracerr::Scene_Sphere *add_sphere();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Sphere> &
    sphere() const;

    // repeated .tracerr.Scene.Triangle triangle = 8;
    int triangle_size() const;

private:
    int _internal_triangle_size() const;

public:
    void clear_triangle();
    ::tracerr::Scene_Triangle *mutable_triangle(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Triangle> *
    mutable_triangle();

private:
    const ::tracerr::Scene_Triangle &_internal_triangle(int index) const;
    ::tracerr::Scene_Triangle *_internal_add_triangle();

public:
    const ::tracerr::Scene_Triangle &triangle(int index) const;
    ::tracerr::Scene_Triangle *add_triangle();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Triangle> &
    triangle() const;

    // repeated .tracerr.Scene.Rectangle rectangle = 9;
    int rectangle_size() const;

private:
    int _internal_rectangle_size() const;

public:
    void clear_rectangle();
    ::tracerr::Scene_Rectangle *mutable_rectangle(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Rectangle> *
    mutable_rectangle();

private:
    const ::tracerr::Scene_Rectangle &_internal_rectangle(int index) const;
    ::tracerr::Scene_Rectangle *_internal_add_rectangle();

public:
    const ::tracerr::Scene_Rectangle &rectangle(int index) const;
    ::tracerr::Scene_Rectangle *add_rectangle();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Rectangle> &
    rectangle() const;

    // repeated .tracerr.Scene.Obj obj = 10;
    int obj_size() const;

private:
    int _internal_obj_size() const;

public:
    void clear_obj();
    ::tracerr::Scene_Obj *mutable_obj(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Obj> *
    mutable_obj();

private:
    const ::tracerr::Scene_Obj &_internal_obj(int index) const;
    ::tracerr::Scene_Obj *_internal_add_obj();

public:
    const ::tracerr::Scene_Obj &obj(int index) const;
    ::tracerr::Scene_Obj *add_obj();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Obj> &
    obj() const;

    // optional string fname = 4 [default = "RenderTest.png"];
    bool has_fname() const;

private:
    bool _internal_has_fname() const;

public:
    void clear_fname();
    const std::string &fname() const;
    void set_fname(const std::string &value);
    void set_fname(std::string &&value);
    void set_fname(const char *value);
    void set_fname(const char *value, size_t size);
    std::string *mutable_fname();
    std::string *release_fname();
    void set_allocated_fname(std::string *fname);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string *unsafe_arena_release_fname();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_fname(
            std::string *fname);

private:
    const std::string &_internal_fname() const;
    void _internal_set_fname(const std::string &value);
    std::string *_internal_mutable_fname();

public:
    // required int32 width = 1;
    bool has_width() const;

private:
    bool _internal_has_width() const;

public:
    void clear_width();
    ::PROTOBUF_NAMESPACE_ID::int32 width() const;
    void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);

private:
    ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
    void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);

public:
    // required int32 height = 2;
    bool has_height() const;

private:
    bool _internal_has_height() const;

public:
    void clear_height();
    ::PROTOBUF_NAMESPACE_ID::int32 height() const;
    void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);

private:
    ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
    void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);

public:
    // required bool saveFile = 3 [default = true];
    bool has_savefile() const;

private:
    bool _internal_has_savefile() const;

public:
    void clear_savefile();
    bool savefile() const;
    void set_savefile(bool value);

private:
    bool _internal_savefile() const;
    void _internal_set_savefile(bool value);

public:
    // optional bool multiThread = 5 [default = true];
    bool has_multithread() const;

private:
    bool _internal_has_multithread() const;

public:
    void clear_multithread();
    bool multithread() const;
    void set_multithread(bool value);

private:
    bool _internal_multithread() const;
    void _internal_set_multithread(bool value);

public:
    // optional bool show_elapsed_time = 11 [default = true];
    bool has_show_elapsed_time() const;

private:
    bool _internal_has_show_elapsed_time() const;

public:
    void clear_show_elapsed_time();
    bool show_elapsed_time() const;
    void set_show_elapsed_time(bool value);

private:
    bool _internal_show_elapsed_time() const;
    void _internal_set_show_elapsed_time(bool value);

public:
    // @@protoc_insertion_point(class_scope:tracerr.Scene)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template<typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Light> light_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Sphere> sphere_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Triangle> triangle_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Rectangle> rectangle_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Obj> obj_;

public:
    static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_fname_;

private:
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fname_;
    ::PROTOBUF_NAMESPACE_ID::int32 width_;
    ::PROTOBUF_NAMESPACE_ID::int32 height_;
    bool savefile_;
    bool multithread_;
    bool show_elapsed_time_;
    friend struct ::TableStruct_scene_2eproto;
  };
  // ===================================================================


  // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif// __GNUC__
  // Scene_Pos

  // required float x = 1;
  inline bool Scene_Pos::_internal_has_x() const {
    bool value = (_has_bits_[0] & 0x00000001u) != 0;
    return value;
  }
  inline bool Scene_Pos::has_x() const {
    return _internal_has_x();
  }
  inline void Scene_Pos::clear_x() {
    x_ = 0;
    _has_bits_[0] &= ~0x00000001u;
  }
  inline float Scene_Pos::_internal_x() const {
    return x_;
  }
  inline float Scene_Pos::x() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Pos.x)
    return _internal_x();
  }
  inline void Scene_Pos::_internal_set_x(float value) {
    _has_bits_[0] |= 0x00000001u;
    x_ = value;
  }
  inline void Scene_Pos::set_x(float value) {
    _internal_set_x(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Pos.x)
  }

  // required float y = 2;
  inline bool Scene_Pos::_internal_has_y() const {
    bool value = (_has_bits_[0] & 0x00000002u) != 0;
    return value;
  }
  inline bool Scene_Pos::has_y() const {
    return _internal_has_y();
  }
  inline void Scene_Pos::clear_y() {
    y_ = 0;
    _has_bits_[0] &= ~0x00000002u;
  }
  inline float Scene_Pos::_internal_y() const {
    return y_;
  }
  inline float Scene_Pos::y() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Pos.y)
    return _internal_y();
  }
  inline void Scene_Pos::_internal_set_y(float value) {
    _has_bits_[0] |= 0x00000002u;
    y_ = value;
  }
  inline void Scene_Pos::set_y(float value) {
    _internal_set_y(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Pos.y)
  }

  // required float z = 3;
  inline bool Scene_Pos::_internal_has_z() const {
    bool value = (_has_bits_[0] & 0x00000004u) != 0;
    return value;
  }
  inline bool Scene_Pos::has_z() const {
    return _internal_has_z();
  }
  inline void Scene_Pos::clear_z() {
    z_ = 0;
    _has_bits_[0] &= ~0x00000004u;
  }
  inline float Scene_Pos::_internal_z() const {
    return z_;
  }
  inline float Scene_Pos::z() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Pos.z)
    return _internal_z();
  }
  inline void Scene_Pos::_internal_set_z(float value) {
    _has_bits_[0] |= 0x00000004u;
    z_ = value;
  }
  inline void Scene_Pos::set_z(float value) {
    _internal_set_z(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Pos.z)
  }

  // -------------------------------------------------------------------

  // Scene_Light

  // required .tracerr.Scene.Pos p = 1;
  inline bool Scene_Light::_internal_has_p() const {
    bool value = (_has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || p_ != nullptr);
    return value;
  }
  inline bool Scene_Light::has_p() const {
    return _internal_has_p();
  }
  inline void Scene_Light::clear_p() {
    if (p_ != nullptr) p_->Clear();
    _has_bits_[0] &= ~0x00000001u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Light::_internal_p() const {
    const ::tracerr::Scene_Pos *p = p_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Light::p() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Light.p)
    return _internal_p();
  }
  inline void Scene_Light::unsafe_arena_set_allocated_p(
          ::tracerr::Scene_Pos *p) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p_);
    }
    p_ = p;
    if (p) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Light.p)
  }
  inline ::tracerr::Scene_Pos *Scene_Light::release_p() {
    auto temp = unsafe_arena_release_p();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Light::unsafe_arena_release_p() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Light.p)
    _has_bits_[0] &= ~0x00000001u;
    ::tracerr::Scene_Pos *temp = p_;
    p_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Light::_internal_mutable_p() {
    _has_bits_[0] |= 0x00000001u;
    if (p_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p_ = p;
    }
    return p_;
  }
  inline ::tracerr::Scene_Pos *Scene_Light::mutable_p() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Light.p)
    return _internal_mutable_p();
  }
  inline void Scene_Light::set_allocated_p(::tracerr::Scene_Pos *p) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p_;
    }
    if (p) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p);
      if (message_arena != submessage_arena) {
        p = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p, submessage_arena);
      }
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    p_ = p;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Light.p)
  }

  // required float intensity = 2;
  inline bool Scene_Light::_internal_has_intensity() const {
    bool value = (_has_bits_[0] & 0x00000002u) != 0;
    return value;
  }
  inline bool Scene_Light::has_intensity() const {
    return _internal_has_intensity();
  }
  inline void Scene_Light::clear_intensity() {
    intensity_ = 0;
    _has_bits_[0] &= ~0x00000002u;
  }
  inline float Scene_Light::_internal_intensity() const {
    return intensity_;
  }
  inline float Scene_Light::intensity() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Light.intensity)
    return _internal_intensity();
  }
  inline void Scene_Light::_internal_set_intensity(float value) {
    _has_bits_[0] |= 0x00000002u;
    intensity_ = value;
  }
  inline void Scene_Light::set_intensity(float value) {
    _internal_set_intensity(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Light.intensity)
  }

  // -------------------------------------------------------------------

  // Scene_Sphere

  // required .tracerr.Scene.Pos p = 1;
  inline bool Scene_Sphere::_internal_has_p() const {
    bool value = (_has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || p_ != nullptr);
    return value;
  }
  inline bool Scene_Sphere::has_p() const {
    return _internal_has_p();
  }
  inline void Scene_Sphere::clear_p() {
    if (p_ != nullptr) p_->Clear();
    _has_bits_[0] &= ~0x00000002u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Sphere::_internal_p() const {
    const ::tracerr::Scene_Pos *p = p_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Sphere::p() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Sphere.p)
    return _internal_p();
  }
  inline void Scene_Sphere::unsafe_arena_set_allocated_p(
          ::tracerr::Scene_Pos *p) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p_);
    }
    p_ = p;
    if (p) {
      _has_bits_[0] |= 0x00000002u;
    } else {
      _has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Sphere.p)
  }
  inline ::tracerr::Scene_Pos *Scene_Sphere::release_p() {
    auto temp = unsafe_arena_release_p();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Sphere::unsafe_arena_release_p() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Sphere.p)
    _has_bits_[0] &= ~0x00000002u;
    ::tracerr::Scene_Pos *temp = p_;
    p_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Sphere::_internal_mutable_p() {
    _has_bits_[0] |= 0x00000002u;
    if (p_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p_ = p;
    }
    return p_;
  }
  inline ::tracerr::Scene_Pos *Scene_Sphere::mutable_p() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Sphere.p)
    return _internal_mutable_p();
  }
  inline void Scene_Sphere::set_allocated_p(::tracerr::Scene_Pos *p) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p_;
    }
    if (p) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p);
      if (message_arena != submessage_arena) {
        p = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p, submessage_arena);
      }
      _has_bits_[0] |= 0x00000002u;
    } else {
      _has_bits_[0] &= ~0x00000002u;
    }
    p_ = p;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Sphere.p)
  }

  // required float radius = 2;
  inline bool Scene_Sphere::_internal_has_radius() const {
    bool value = (_has_bits_[0] & 0x00000004u) != 0;
    return value;
  }
  inline bool Scene_Sphere::has_radius() const {
    return _internal_has_radius();
  }
  inline void Scene_Sphere::clear_radius() {
    radius_ = 0;
    _has_bits_[0] &= ~0x00000004u;
  }
  inline float Scene_Sphere::_internal_radius() const {
    return radius_;
  }
  inline float Scene_Sphere::radius() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Sphere.radius)
    return _internal_radius();
  }
  inline void Scene_Sphere::_internal_set_radius(float value) {
    _has_bits_[0] |= 0x00000004u;
    radius_ = value;
  }
  inline void Scene_Sphere::set_radius(float value) {
    _internal_set_radius(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Sphere.radius)
  }

  // required string material = 3;
  inline bool Scene_Sphere::_internal_has_material() const {
    bool value = (_has_bits_[0] & 0x00000001u) != 0;
    return value;
  }
  inline bool Scene_Sphere::has_material() const {
    return _internal_has_material();
  }
  inline void Scene_Sphere::clear_material() {
    material_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    _has_bits_[0] &= ~0x00000001u;
  }
  inline const std::string &Scene_Sphere::material() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Sphere.material)
    return _internal_material();
  }
  inline void Scene_Sphere::set_material(const std::string &value) {
    _internal_set_material(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Sphere.material)
  }
  inline std::string *Scene_Sphere::mutable_material() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Sphere.material)
    return _internal_mutable_material();
  }
  inline const std::string &Scene_Sphere::_internal_material() const {
    return material_.Get();
  }
  inline void Scene_Sphere::_internal_set_material(const std::string &value) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
  }
  inline void Scene_Sphere::set_material(std::string &&value) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(
            &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
    // @@protoc_insertion_point(field_set_rvalue:tracerr.Scene.Sphere.material)
  }
  inline void Scene_Sphere::set_material(const char *value) {
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
                  GetArena());
    // @@protoc_insertion_point(field_set_char:tracerr.Scene.Sphere.material)
  }
  inline void Scene_Sphere::set_material(const char *value,
                                         size_t size) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(reinterpret_cast<const char *>(value), size), GetArena());
    // @@protoc_insertion_point(field_set_pointer:tracerr.Scene.Sphere.material)
  }
  inline std::string *Scene_Sphere::_internal_mutable_material() {
    _has_bits_[0] |= 0x00000001u;
    return material_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline std::string *Scene_Sphere::release_material() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Sphere.material)
    if (!_internal_has_material()) {
      return nullptr;
    }
    _has_bits_[0] &= ~0x00000001u;
    return material_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline void Scene_Sphere::set_allocated_material(std::string *material) {
    if (material != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    material_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), material,
                           GetArena());
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Sphere.material)
  }
  inline std::string *Scene_Sphere::unsafe_arena_release_material() {
    // @@protoc_insertion_point(field_unsafe_arena_release:tracerr.Scene.Sphere.material)
    GOOGLE_DCHECK(GetArena() != nullptr);
    _has_bits_[0] &= ~0x00000001u;
    return material_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                        GetArena());
  }
  inline void Scene_Sphere::unsafe_arena_set_allocated_material(
          std::string *material) {
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (material != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    material_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                      material, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Sphere.material)
  }

  // -------------------------------------------------------------------

  // Scene_Triangle

  // required .tracerr.Scene.Pos p0 = 1;
  inline bool Scene_Triangle::_internal_has_p0() const {
    bool value = (_has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || p0_ != nullptr);
    return value;
  }
  inline bool Scene_Triangle::has_p0() const {
    return _internal_has_p0();
  }
  inline void Scene_Triangle::clear_p0() {
    if (p0_ != nullptr) p0_->Clear();
    _has_bits_[0] &= ~0x00000002u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Triangle::_internal_p0() const {
    const ::tracerr::Scene_Pos *p = p0_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Triangle::p0() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Triangle.p0)
    return _internal_p0();
  }
  inline void Scene_Triangle::unsafe_arena_set_allocated_p0(
          ::tracerr::Scene_Pos *p0) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p0_);
    }
    p0_ = p0;
    if (p0) {
      _has_bits_[0] |= 0x00000002u;
    } else {
      _has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Triangle.p0)
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::release_p0() {
    auto temp = unsafe_arena_release_p0();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::unsafe_arena_release_p0() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Triangle.p0)
    _has_bits_[0] &= ~0x00000002u;
    ::tracerr::Scene_Pos *temp = p0_;
    p0_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::_internal_mutable_p0() {
    _has_bits_[0] |= 0x00000002u;
    if (p0_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p0_ = p;
    }
    return p0_;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::mutable_p0() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Triangle.p0)
    return _internal_mutable_p0();
  }
  inline void Scene_Triangle::set_allocated_p0(::tracerr::Scene_Pos *p0) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p0_;
    }
    if (p0) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p0);
      if (message_arena != submessage_arena) {
        p0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p0, submessage_arena);
      }
      _has_bits_[0] |= 0x00000002u;
    } else {
      _has_bits_[0] &= ~0x00000002u;
    }
    p0_ = p0;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Triangle.p0)
  }

  // required .tracerr.Scene.Pos p1 = 2;
  inline bool Scene_Triangle::_internal_has_p1() const {
    bool value = (_has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || p1_ != nullptr);
    return value;
  }
  inline bool Scene_Triangle::has_p1() const {
    return _internal_has_p1();
  }
  inline void Scene_Triangle::clear_p1() {
    if (p1_ != nullptr) p1_->Clear();
    _has_bits_[0] &= ~0x00000004u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Triangle::_internal_p1() const {
    const ::tracerr::Scene_Pos *p = p1_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Triangle::p1() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Triangle.p1)
    return _internal_p1();
  }
  inline void Scene_Triangle::unsafe_arena_set_allocated_p1(
          ::tracerr::Scene_Pos *p1) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p1_);
    }
    p1_ = p1;
    if (p1) {
      _has_bits_[0] |= 0x00000004u;
    } else {
      _has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Triangle.p1)
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::release_p1() {
    auto temp = unsafe_arena_release_p1();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::unsafe_arena_release_p1() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Triangle.p1)
    _has_bits_[0] &= ~0x00000004u;
    ::tracerr::Scene_Pos *temp = p1_;
    p1_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::_internal_mutable_p1() {
    _has_bits_[0] |= 0x00000004u;
    if (p1_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p1_ = p;
    }
    return p1_;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::mutable_p1() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Triangle.p1)
    return _internal_mutable_p1();
  }
  inline void Scene_Triangle::set_allocated_p1(::tracerr::Scene_Pos *p1) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p1_;
    }
    if (p1) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p1);
      if (message_arena != submessage_arena) {
        p1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p1, submessage_arena);
      }
      _has_bits_[0] |= 0x00000004u;
    } else {
      _has_bits_[0] &= ~0x00000004u;
    }
    p1_ = p1;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Triangle.p1)
  }

  // required .tracerr.Scene.Pos p2 = 3;
  inline bool Scene_Triangle::_internal_has_p2() const {
    bool value = (_has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || p2_ != nullptr);
    return value;
  }
  inline bool Scene_Triangle::has_p2() const {
    return _internal_has_p2();
  }
  inline void Scene_Triangle::clear_p2() {
    if (p2_ != nullptr) p2_->Clear();
    _has_bits_[0] &= ~0x00000008u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Triangle::_internal_p2() const {
    const ::tracerr::Scene_Pos *p = p2_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Triangle::p2() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Triangle.p2)
    return _internal_p2();
  }
  inline void Scene_Triangle::unsafe_arena_set_allocated_p2(
          ::tracerr::Scene_Pos *p2) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p2_);
    }
    p2_ = p2;
    if (p2) {
      _has_bits_[0] |= 0x00000008u;
    } else {
      _has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Triangle.p2)
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::release_p2() {
    auto temp = unsafe_arena_release_p2();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::unsafe_arena_release_p2() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Triangle.p2)
    _has_bits_[0] &= ~0x00000008u;
    ::tracerr::Scene_Pos *temp = p2_;
    p2_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::_internal_mutable_p2() {
    _has_bits_[0] |= 0x00000008u;
    if (p2_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p2_ = p;
    }
    return p2_;
  }
  inline ::tracerr::Scene_Pos *Scene_Triangle::mutable_p2() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Triangle.p2)
    return _internal_mutable_p2();
  }
  inline void Scene_Triangle::set_allocated_p2(::tracerr::Scene_Pos *p2) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p2_;
    }
    if (p2) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p2);
      if (message_arena != submessage_arena) {
        p2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p2, submessage_arena);
      }
      _has_bits_[0] |= 0x00000008u;
    } else {
      _has_bits_[0] &= ~0x00000008u;
    }
    p2_ = p2;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Triangle.p2)
  }

  // required string material = 4;
  inline bool Scene_Triangle::_internal_has_material() const {
    bool value = (_has_bits_[0] & 0x00000001u) != 0;
    return value;
  }
  inline bool Scene_Triangle::has_material() const {
    return _internal_has_material();
  }
  inline void Scene_Triangle::clear_material() {
    material_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    _has_bits_[0] &= ~0x00000001u;
  }
  inline const std::string &Scene_Triangle::material() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Triangle.material)
    return _internal_material();
  }
  inline void Scene_Triangle::set_material(const std::string &value) {
    _internal_set_material(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Triangle.material)
  }
  inline std::string *Scene_Triangle::mutable_material() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Triangle.material)
    return _internal_mutable_material();
  }
  inline const std::string &Scene_Triangle::_internal_material() const {
    return material_.Get();
  }
  inline void Scene_Triangle::_internal_set_material(const std::string &value) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
  }
  inline void Scene_Triangle::set_material(std::string &&value) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(
            &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
    // @@protoc_insertion_point(field_set_rvalue:tracerr.Scene.Triangle.material)
  }
  inline void Scene_Triangle::set_material(const char *value) {
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
                  GetArena());
    // @@protoc_insertion_point(field_set_char:tracerr.Scene.Triangle.material)
  }
  inline void Scene_Triangle::set_material(const char *value,
                                           size_t size) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(reinterpret_cast<const char *>(value), size), GetArena());
    // @@protoc_insertion_point(field_set_pointer:tracerr.Scene.Triangle.material)
  }
  inline std::string *Scene_Triangle::_internal_mutable_material() {
    _has_bits_[0] |= 0x00000001u;
    return material_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline std::string *Scene_Triangle::release_material() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Triangle.material)
    if (!_internal_has_material()) {
      return nullptr;
    }
    _has_bits_[0] &= ~0x00000001u;
    return material_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline void Scene_Triangle::set_allocated_material(std::string *material) {
    if (material != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    material_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), material,
                           GetArena());
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Triangle.material)
  }
  inline std::string *Scene_Triangle::unsafe_arena_release_material() {
    // @@protoc_insertion_point(field_unsafe_arena_release:tracerr.Scene.Triangle.material)
    GOOGLE_DCHECK(GetArena() != nullptr);
    _has_bits_[0] &= ~0x00000001u;
    return material_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                        GetArena());
  }
  inline void Scene_Triangle::unsafe_arena_set_allocated_material(
          std::string *material) {
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (material != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    material_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                      material, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Triangle.material)
  }

  // -------------------------------------------------------------------

  // Scene_Rectangle

  // required .tracerr.Scene.Pos p0 = 1;
  inline bool Scene_Rectangle::_internal_has_p0() const {
    bool value = (_has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || p0_ != nullptr);
    return value;
  }
  inline bool Scene_Rectangle::has_p0() const {
    return _internal_has_p0();
  }
  inline void Scene_Rectangle::clear_p0() {
    if (p0_ != nullptr) p0_->Clear();
    _has_bits_[0] &= ~0x00000002u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Rectangle::_internal_p0() const {
    const ::tracerr::Scene_Pos *p = p0_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Rectangle::p0() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Rectangle.p0)
    return _internal_p0();
  }
  inline void Scene_Rectangle::unsafe_arena_set_allocated_p0(
          ::tracerr::Scene_Pos *p0) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p0_);
    }
    p0_ = p0;
    if (p0) {
      _has_bits_[0] |= 0x00000002u;
    } else {
      _has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Rectangle.p0)
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::release_p0() {
    auto temp = unsafe_arena_release_p0();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::unsafe_arena_release_p0() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Rectangle.p0)
    _has_bits_[0] &= ~0x00000002u;
    ::tracerr::Scene_Pos *temp = p0_;
    p0_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::_internal_mutable_p0() {
    _has_bits_[0] |= 0x00000002u;
    if (p0_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p0_ = p;
    }
    return p0_;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::mutable_p0() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Rectangle.p0)
    return _internal_mutable_p0();
  }
  inline void Scene_Rectangle::set_allocated_p0(::tracerr::Scene_Pos *p0) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p0_;
    }
    if (p0) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p0);
      if (message_arena != submessage_arena) {
        p0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p0, submessage_arena);
      }
      _has_bits_[0] |= 0x00000002u;
    } else {
      _has_bits_[0] &= ~0x00000002u;
    }
    p0_ = p0;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Rectangle.p0)
  }

  // required .tracerr.Scene.Pos p1 = 2;
  inline bool Scene_Rectangle::_internal_has_p1() const {
    bool value = (_has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || p1_ != nullptr);
    return value;
  }
  inline bool Scene_Rectangle::has_p1() const {
    return _internal_has_p1();
  }
  inline void Scene_Rectangle::clear_p1() {
    if (p1_ != nullptr) p1_->Clear();
    _has_bits_[0] &= ~0x00000004u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Rectangle::_internal_p1() const {
    const ::tracerr::Scene_Pos *p = p1_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Rectangle::p1() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Rectangle.p1)
    return _internal_p1();
  }
  inline void Scene_Rectangle::unsafe_arena_set_allocated_p1(
          ::tracerr::Scene_Pos *p1) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p1_);
    }
    p1_ = p1;
    if (p1) {
      _has_bits_[0] |= 0x00000004u;
    } else {
      _has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Rectangle.p1)
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::release_p1() {
    auto temp = unsafe_arena_release_p1();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::unsafe_arena_release_p1() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Rectangle.p1)
    _has_bits_[0] &= ~0x00000004u;
    ::tracerr::Scene_Pos *temp = p1_;
    p1_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::_internal_mutable_p1() {
    _has_bits_[0] |= 0x00000004u;
    if (p1_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p1_ = p;
    }
    return p1_;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::mutable_p1() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Rectangle.p1)
    return _internal_mutable_p1();
  }
  inline void Scene_Rectangle::set_allocated_p1(::tracerr::Scene_Pos *p1) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p1_;
    }
    if (p1) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p1);
      if (message_arena != submessage_arena) {
        p1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p1, submessage_arena);
      }
      _has_bits_[0] |= 0x00000004u;
    } else {
      _has_bits_[0] &= ~0x00000004u;
    }
    p1_ = p1;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Rectangle.p1)
  }

  // required .tracerr.Scene.Pos p2 = 3;
  inline bool Scene_Rectangle::_internal_has_p2() const {
    bool value = (_has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || p2_ != nullptr);
    return value;
  }
  inline bool Scene_Rectangle::has_p2() const {
    return _internal_has_p2();
  }
  inline void Scene_Rectangle::clear_p2() {
    if (p2_ != nullptr) p2_->Clear();
    _has_bits_[0] &= ~0x00000008u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Rectangle::_internal_p2() const {
    const ::tracerr::Scene_Pos *p = p2_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Rectangle::p2() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Rectangle.p2)
    return _internal_p2();
  }
  inline void Scene_Rectangle::unsafe_arena_set_allocated_p2(
          ::tracerr::Scene_Pos *p2) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p2_);
    }
    p2_ = p2;
    if (p2) {
      _has_bits_[0] |= 0x00000008u;
    } else {
      _has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Rectangle.p2)
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::release_p2() {
    auto temp = unsafe_arena_release_p2();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::unsafe_arena_release_p2() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Rectangle.p2)
    _has_bits_[0] &= ~0x00000008u;
    ::tracerr::Scene_Pos *temp = p2_;
    p2_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::_internal_mutable_p2() {
    _has_bits_[0] |= 0x00000008u;
    if (p2_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p2_ = p;
    }
    return p2_;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::mutable_p2() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Rectangle.p2)
    return _internal_mutable_p2();
  }
  inline void Scene_Rectangle::set_allocated_p2(::tracerr::Scene_Pos *p2) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p2_;
    }
    if (p2) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p2);
      if (message_arena != submessage_arena) {
        p2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p2, submessage_arena);
      }
      _has_bits_[0] |= 0x00000008u;
    } else {
      _has_bits_[0] &= ~0x00000008u;
    }
    p2_ = p2;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Rectangle.p2)
  }

  // required .tracerr.Scene.Pos p3 = 4;
  inline bool Scene_Rectangle::_internal_has_p3() const {
    bool value = (_has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || p3_ != nullptr);
    return value;
  }
  inline bool Scene_Rectangle::has_p3() const {
    return _internal_has_p3();
  }
  inline void Scene_Rectangle::clear_p3() {
    if (p3_ != nullptr) p3_->Clear();
    _has_bits_[0] &= ~0x00000010u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Rectangle::_internal_p3() const {
    const ::tracerr::Scene_Pos *p = p3_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Rectangle::p3() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Rectangle.p3)
    return _internal_p3();
  }
  inline void Scene_Rectangle::unsafe_arena_set_allocated_p3(
          ::tracerr::Scene_Pos *p3) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(p3_);
    }
    p3_ = p3;
    if (p3) {
      _has_bits_[0] |= 0x00000010u;
    } else {
      _has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Rectangle.p3)
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::release_p3() {
    auto temp = unsafe_arena_release_p3();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::unsafe_arena_release_p3() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Rectangle.p3)
    _has_bits_[0] &= ~0x00000010u;
    ::tracerr::Scene_Pos *temp = p3_;
    p3_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::_internal_mutable_p3() {
    _has_bits_[0] |= 0x00000010u;
    if (p3_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      p3_ = p;
    }
    return p3_;
  }
  inline ::tracerr::Scene_Pos *Scene_Rectangle::mutable_p3() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Rectangle.p3)
    return _internal_mutable_p3();
  }
  inline void Scene_Rectangle::set_allocated_p3(::tracerr::Scene_Pos *p3) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete p3_;
    }
    if (p3) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p3);
      if (message_arena != submessage_arena) {
        p3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, p3, submessage_arena);
      }
      _has_bits_[0] |= 0x00000010u;
    } else {
      _has_bits_[0] &= ~0x00000010u;
    }
    p3_ = p3;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Rectangle.p3)
  }

  // required string material = 5;
  inline bool Scene_Rectangle::_internal_has_material() const {
    bool value = (_has_bits_[0] & 0x00000001u) != 0;
    return value;
  }
  inline bool Scene_Rectangle::has_material() const {
    return _internal_has_material();
  }
  inline void Scene_Rectangle::clear_material() {
    material_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    _has_bits_[0] &= ~0x00000001u;
  }
  inline const std::string &Scene_Rectangle::material() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Rectangle.material)
    return _internal_material();
  }
  inline void Scene_Rectangle::set_material(const std::string &value) {
    _internal_set_material(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Rectangle.material)
  }
  inline std::string *Scene_Rectangle::mutable_material() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Rectangle.material)
    return _internal_mutable_material();
  }
  inline const std::string &Scene_Rectangle::_internal_material() const {
    return material_.Get();
  }
  inline void Scene_Rectangle::_internal_set_material(const std::string &value) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
  }
  inline void Scene_Rectangle::set_material(std::string &&value) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(
            &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
    // @@protoc_insertion_point(field_set_rvalue:tracerr.Scene.Rectangle.material)
  }
  inline void Scene_Rectangle::set_material(const char *value) {
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
                  GetArena());
    // @@protoc_insertion_point(field_set_char:tracerr.Scene.Rectangle.material)
  }
  inline void Scene_Rectangle::set_material(const char *value,
                                            size_t size) {
    _has_bits_[0] |= 0x00000001u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(reinterpret_cast<const char *>(value), size), GetArena());
    // @@protoc_insertion_point(field_set_pointer:tracerr.Scene.Rectangle.material)
  }
  inline std::string *Scene_Rectangle::_internal_mutable_material() {
    _has_bits_[0] |= 0x00000001u;
    return material_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline std::string *Scene_Rectangle::release_material() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Rectangle.material)
    if (!_internal_has_material()) {
      return nullptr;
    }
    _has_bits_[0] &= ~0x00000001u;
    return material_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline void Scene_Rectangle::set_allocated_material(std::string *material) {
    if (material != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    material_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), material,
                           GetArena());
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Rectangle.material)
  }
  inline std::string *Scene_Rectangle::unsafe_arena_release_material() {
    // @@protoc_insertion_point(field_unsafe_arena_release:tracerr.Scene.Rectangle.material)
    GOOGLE_DCHECK(GetArena() != nullptr);
    _has_bits_[0] &= ~0x00000001u;
    return material_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                        GetArena());
  }
  inline void Scene_Rectangle::unsafe_arena_set_allocated_material(
          std::string *material) {
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (material != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    material_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                      material, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Rectangle.material)
  }

  // -------------------------------------------------------------------

  // Scene_Obj

  // required string fname = 1;
  inline bool Scene_Obj::_internal_has_fname() const {
    bool value = (_has_bits_[0] & 0x00000001u) != 0;
    return value;
  }
  inline bool Scene_Obj::has_fname() const {
    return _internal_has_fname();
  }
  inline void Scene_Obj::clear_fname() {
    fname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    _has_bits_[0] &= ~0x00000001u;
  }
  inline const std::string &Scene_Obj::fname() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Obj.fname)
    return _internal_fname();
  }
  inline void Scene_Obj::set_fname(const std::string &value) {
    _internal_set_fname(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Obj.fname)
  }
  inline std::string *Scene_Obj::mutable_fname() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Obj.fname)
    return _internal_mutable_fname();
  }
  inline const std::string &Scene_Obj::_internal_fname() const {
    return fname_.Get();
  }
  inline void Scene_Obj::_internal_set_fname(const std::string &value) {
    _has_bits_[0] |= 0x00000001u;
    fname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
  }
  inline void Scene_Obj::set_fname(std::string &&value) {
    _has_bits_[0] |= 0x00000001u;
    fname_.Set(
            &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
    // @@protoc_insertion_point(field_set_rvalue:tracerr.Scene.Obj.fname)
  }
  inline void Scene_Obj::set_fname(const char *value) {
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000001u;
    fname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
               GetArena());
    // @@protoc_insertion_point(field_set_char:tracerr.Scene.Obj.fname)
  }
  inline void Scene_Obj::set_fname(const char *value,
                                   size_t size) {
    _has_bits_[0] |= 0x00000001u;
    fname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(reinterpret_cast<const char *>(value), size), GetArena());
    // @@protoc_insertion_point(field_set_pointer:tracerr.Scene.Obj.fname)
  }
  inline std::string *Scene_Obj::_internal_mutable_fname() {
    _has_bits_[0] |= 0x00000001u;
    return fname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline std::string *Scene_Obj::release_fname() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Obj.fname)
    if (!_internal_has_fname()) {
      return nullptr;
    }
    _has_bits_[0] &= ~0x00000001u;
    return fname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline void Scene_Obj::set_allocated_fname(std::string *fname) {
    if (fname != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    fname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fname,
                        GetArena());
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Obj.fname)
  }
  inline std::string *Scene_Obj::unsafe_arena_release_fname() {
    // @@protoc_insertion_point(field_unsafe_arena_release:tracerr.Scene.Obj.fname)
    GOOGLE_DCHECK(GetArena() != nullptr);
    _has_bits_[0] &= ~0x00000001u;
    return fname_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                     GetArena());
  }
  inline void Scene_Obj::unsafe_arena_set_allocated_fname(
          std::string *fname) {
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (fname != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    fname_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                   fname, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Obj.fname)
  }

  // required string material = 2;
  inline bool Scene_Obj::_internal_has_material() const {
    bool value = (_has_bits_[0] & 0x00000002u) != 0;
    return value;
  }
  inline bool Scene_Obj::has_material() const {
    return _internal_has_material();
  }
  inline void Scene_Obj::clear_material() {
    material_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    _has_bits_[0] &= ~0x00000002u;
  }
  inline const std::string &Scene_Obj::material() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Obj.material)
    return _internal_material();
  }
  inline void Scene_Obj::set_material(const std::string &value) {
    _internal_set_material(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.Obj.material)
  }
  inline std::string *Scene_Obj::mutable_material() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Obj.material)
    return _internal_mutable_material();
  }
  inline const std::string &Scene_Obj::_internal_material() const {
    return material_.Get();
  }
  inline void Scene_Obj::_internal_set_material(const std::string &value) {
    _has_bits_[0] |= 0x00000002u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
  }
  inline void Scene_Obj::set_material(std::string &&value) {
    _has_bits_[0] |= 0x00000002u;
    material_.Set(
            &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
    // @@protoc_insertion_point(field_set_rvalue:tracerr.Scene.Obj.material)
  }
  inline void Scene_Obj::set_material(const char *value) {
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000002u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
                  GetArena());
    // @@protoc_insertion_point(field_set_char:tracerr.Scene.Obj.material)
  }
  inline void Scene_Obj::set_material(const char *value,
                                      size_t size) {
    _has_bits_[0] |= 0x00000002u;
    material_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(reinterpret_cast<const char *>(value), size), GetArena());
    // @@protoc_insertion_point(field_set_pointer:tracerr.Scene.Obj.material)
  }
  inline std::string *Scene_Obj::_internal_mutable_material() {
    _has_bits_[0] |= 0x00000002u;
    return material_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline std::string *Scene_Obj::release_material() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Obj.material)
    if (!_internal_has_material()) {
      return nullptr;
    }
    _has_bits_[0] &= ~0x00000002u;
    return material_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  }
  inline void Scene_Obj::set_allocated_material(std::string *material) {
    if (material != nullptr) {
      _has_bits_[0] |= 0x00000002u;
    } else {
      _has_bits_[0] &= ~0x00000002u;
    }
    material_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), material,
                           GetArena());
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Obj.material)
  }
  inline std::string *Scene_Obj::unsafe_arena_release_material() {
    // @@protoc_insertion_point(field_unsafe_arena_release:tracerr.Scene.Obj.material)
    GOOGLE_DCHECK(GetArena() != nullptr);
    _has_bits_[0] &= ~0x00000002u;
    return material_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                        GetArena());
  }
  inline void Scene_Obj::unsafe_arena_set_allocated_material(
          std::string *material) {
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (material != nullptr) {
      _has_bits_[0] |= 0x00000002u;
    } else {
      _has_bits_[0] &= ~0x00000002u;
    }
    material_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                      material, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Obj.material)
  }

  // optional .tracerr.Scene.Pos translation = 3;
  inline bool Scene_Obj::_internal_has_translation() const {
    bool value = (_has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || translation_ != nullptr);
    return value;
  }
  inline bool Scene_Obj::has_translation() const {
    return _internal_has_translation();
  }
  inline void Scene_Obj::clear_translation() {
    if (translation_ != nullptr) translation_->Clear();
    _has_bits_[0] &= ~0x00000004u;
  }
  inline const ::tracerr::Scene_Pos &Scene_Obj::_internal_translation() const {
    const ::tracerr::Scene_Pos *p = translation_;
    return p != nullptr ? *p : *reinterpret_cast<const ::tracerr::Scene_Pos *>(&::tracerr::_Scene_Pos_default_instance_);
  }
  inline const ::tracerr::Scene_Pos &Scene_Obj::translation() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.Obj.translation)
    return _internal_translation();
  }
  inline void Scene_Obj::unsafe_arena_set_allocated_translation(
          ::tracerr::Scene_Pos *translation) {
    if (GetArena() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(translation_);
    }
    translation_ = translation;
    if (translation) {
      _has_bits_[0] |= 0x00000004u;
    } else {
      _has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.Obj.translation)
  }
  inline ::tracerr::Scene_Pos *Scene_Obj::release_translation() {
    auto temp = unsafe_arena_release_translation();
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Obj::unsafe_arena_release_translation() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.Obj.translation)
    _has_bits_[0] &= ~0x00000004u;
    ::tracerr::Scene_Pos *temp = translation_;
    translation_ = nullptr;
    return temp;
  }
  inline ::tracerr::Scene_Pos *Scene_Obj::_internal_mutable_translation() {
    _has_bits_[0] |= 0x00000004u;
    if (translation_ == nullptr) {
      auto *p = CreateMaybeMessage<::tracerr::Scene_Pos>(GetArena());
      translation_ = p;
    }
    return translation_;
  }
  inline ::tracerr::Scene_Pos *Scene_Obj::mutable_translation() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.Obj.translation)
    return _internal_mutable_translation();
  }
  inline void Scene_Obj::set_allocated_translation(::tracerr::Scene_Pos *translation) {
    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArena();
    if (message_arena == nullptr) {
      delete translation_;
    }
    if (translation) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(translation);
      if (message_arena != submessage_arena) {
        translation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, translation, submessage_arena);
      }
      _has_bits_[0] |= 0x00000004u;
    } else {
      _has_bits_[0] &= ~0x00000004u;
    }
    translation_ = translation;
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.Obj.translation)
  }

  // -------------------------------------------------------------------

  // Scene

  // required int32 width = 1;
  inline bool Scene::_internal_has_width() const {
    bool value = (_has_bits_[0] & 0x00000002u) != 0;
    return value;
  }
  inline bool Scene::has_width() const {
    return _internal_has_width();
  }
  inline void Scene::clear_width() {
    width_ = 0;
    _has_bits_[0] &= ~0x00000002u;
  }
  inline ::PROTOBUF_NAMESPACE_ID::int32 Scene::_internal_width() const {
    return width_;
  }
  inline ::PROTOBUF_NAMESPACE_ID::int32 Scene::width() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.width)
    return _internal_width();
  }
  inline void Scene::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
    _has_bits_[0] |= 0x00000002u;
    width_ = value;
  }
  inline void Scene::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
    _internal_set_width(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.width)
  }

  // required int32 height = 2;
  inline bool Scene::_internal_has_height() const {
    bool value = (_has_bits_[0] & 0x00000004u) != 0;
    return value;
  }
  inline bool Scene::has_height() const {
    return _internal_has_height();
  }
  inline void Scene::clear_height() {
    height_ = 0;
    _has_bits_[0] &= ~0x00000004u;
  }
  inline ::PROTOBUF_NAMESPACE_ID::int32 Scene::_internal_height() const {
    return height_;
  }
  inline ::PROTOBUF_NAMESPACE_ID::int32 Scene::height() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.height)
    return _internal_height();
  }
  inline void Scene::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
    _has_bits_[0] |= 0x00000004u;
    height_ = value;
  }
  inline void Scene::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
    _internal_set_height(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.height)
  }

  // required bool saveFile = 3 [default = true];
  inline bool Scene::_internal_has_savefile() const {
    bool value = (_has_bits_[0] & 0x00000008u) != 0;
    return value;
  }
  inline bool Scene::has_savefile() const {
    return _internal_has_savefile();
  }
  inline void Scene::clear_savefile() {
    savefile_ = true;
    _has_bits_[0] &= ~0x00000008u;
  }
  inline bool Scene::_internal_savefile() const {
    return savefile_;
  }
  inline bool Scene::savefile() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.saveFile)
    return _internal_savefile();
  }
  inline void Scene::_internal_set_savefile(bool value) {
    _has_bits_[0] |= 0x00000008u;
    savefile_ = value;
  }
  inline void Scene::set_savefile(bool value) {
    _internal_set_savefile(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.saveFile)
  }

  // optional string fname = 4 [default = "RenderTest.png"];
  inline bool Scene::_internal_has_fname() const {
    bool value = (_has_bits_[0] & 0x00000001u) != 0;
    return value;
  }
  inline bool Scene::has_fname() const {
    return _internal_has_fname();
  }
  inline void Scene::clear_fname() {
    fname_.ClearToDefault(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(), GetArena());
    _has_bits_[0] &= ~0x00000001u;
  }
  inline const std::string &Scene::fname() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.fname)
    return _internal_fname();
  }
  inline void Scene::set_fname(const std::string &value) {
    _internal_set_fname(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.fname)
  }
  inline std::string *Scene::mutable_fname() {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.fname)
    return _internal_mutable_fname();
  }
  inline const std::string &Scene::_internal_fname() const {
    return fname_.Get();
  }
  inline void Scene::_internal_set_fname(const std::string &value) {
    _has_bits_[0] |= 0x00000001u;
    fname_.Set(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(), value, GetArena());
  }
  inline void Scene::set_fname(std::string &&value) {
    _has_bits_[0] |= 0x00000001u;
    fname_.Set(
            &::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(), ::std::move(value), GetArena());
    // @@protoc_insertion_point(field_set_rvalue:tracerr.Scene.fname)
  }
  inline void Scene::set_fname(const char *value) {
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000001u;
    fname_.Set(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(), ::std::string(value),
               GetArena());
    // @@protoc_insertion_point(field_set_char:tracerr.Scene.fname)
  }
  inline void Scene::set_fname(const char *value,
                               size_t size) {
    _has_bits_[0] |= 0x00000001u;
    fname_.Set(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(), ::std::string(reinterpret_cast<const char *>(value), size), GetArena());
    // @@protoc_insertion_point(field_set_pointer:tracerr.Scene.fname)
  }
  inline std::string *Scene::_internal_mutable_fname() {
    _has_bits_[0] |= 0x00000001u;
    return fname_.Mutable(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(), GetArena());
  }
  inline std::string *Scene::release_fname() {
    // @@protoc_insertion_point(field_release:tracerr.Scene.fname)
    if (!_internal_has_fname()) {
      return nullptr;
    }
    _has_bits_[0] &= ~0x00000001u;
    return fname_.ReleaseNonDefault(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(), GetArena());
  }
  inline void Scene::set_allocated_fname(std::string *fname) {
    if (fname != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    fname_.SetAllocated(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(), fname,
                        GetArena());
    // @@protoc_insertion_point(field_set_allocated:tracerr.Scene.fname)
  }
  inline std::string *Scene::unsafe_arena_release_fname() {
    // @@protoc_insertion_point(field_unsafe_arena_release:tracerr.Scene.fname)
    GOOGLE_DCHECK(GetArena() != nullptr);
    _has_bits_[0] &= ~0x00000001u;
    return fname_.UnsafeArenaRelease(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(),
                                     GetArena());
  }
  inline void Scene::unsafe_arena_set_allocated_fname(
          std::string *fname) {
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (fname != nullptr) {
      _has_bits_[0] |= 0x00000001u;
    } else {
      _has_bits_[0] &= ~0x00000001u;
    }
    fname_.UnsafeArenaSetAllocated(&::tracerr::Scene::_i_give_permission_to_break_this_code_default_fname_.get(),
                                   fname, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracerr.Scene.fname)
  }

  // optional bool multiThread = 5 [default = true];
  inline bool Scene::_internal_has_multithread() const {
    bool value = (_has_bits_[0] & 0x00000010u) != 0;
    return value;
  }
  inline bool Scene::has_multithread() const {
    return _internal_has_multithread();
  }
  inline void Scene::clear_multithread() {
    multithread_ = true;
    _has_bits_[0] &= ~0x00000010u;
  }
  inline bool Scene::_internal_multithread() const {
    return multithread_;
  }
  inline bool Scene::multithread() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.multiThread)
    return _internal_multithread();
  }
  inline void Scene::_internal_set_multithread(bool value) {
    _has_bits_[0] |= 0x00000010u;
    multithread_ = value;
  }
  inline void Scene::set_multithread(bool value) {
    _internal_set_multithread(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.multiThread)
  }

  // repeated .tracerr.Scene.Light light = 6;
  inline int Scene::_internal_light_size() const {
    return light_.size();
  }
  inline int Scene::light_size() const {
    return _internal_light_size();
  }
  inline void Scene::clear_light() {
    light_.Clear();
  }
  inline ::tracerr::Scene_Light *Scene::mutable_light(int index) {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.light)
    return light_.Mutable(index);
  }
  inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Light> *
  Scene::mutable_light() {
    // @@protoc_insertion_point(field_mutable_list:tracerr.Scene.light)
    return &light_;
  }
  inline const ::tracerr::Scene_Light &Scene::_internal_light(int index) const {
    return light_.Get(index);
  }
  inline const ::tracerr::Scene_Light &Scene::light(int index) const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.light)
    return _internal_light(index);
  }
  inline ::tracerr::Scene_Light *Scene::_internal_add_light() {
    return light_.Add();
  }
  inline ::tracerr::Scene_Light *Scene::add_light() {
    // @@protoc_insertion_point(field_add:tracerr.Scene.light)
    return _internal_add_light();
  }
  inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Light> &
  Scene::light() const {
    // @@protoc_insertion_point(field_list:tracerr.Scene.light)
    return light_;
  }

  // repeated .tracerr.Scene.Sphere sphere = 7;
  inline int Scene::_internal_sphere_size() const {
    return sphere_.size();
  }
  inline int Scene::sphere_size() const {
    return _internal_sphere_size();
  }
  inline void Scene::clear_sphere() {
    sphere_.Clear();
  }
  inline ::tracerr::Scene_Sphere *Scene::mutable_sphere(int index) {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.sphere)
    return sphere_.Mutable(index);
  }
  inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Sphere> *
  Scene::mutable_sphere() {
    // @@protoc_insertion_point(field_mutable_list:tracerr.Scene.sphere)
    return &sphere_;
  }
  inline const ::tracerr::Scene_Sphere &Scene::_internal_sphere(int index) const {
    return sphere_.Get(index);
  }
  inline const ::tracerr::Scene_Sphere &Scene::sphere(int index) const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.sphere)
    return _internal_sphere(index);
  }
  inline ::tracerr::Scene_Sphere *Scene::_internal_add_sphere() {
    return sphere_.Add();
  }
  inline ::tracerr::Scene_Sphere *Scene::add_sphere() {
    // @@protoc_insertion_point(field_add:tracerr.Scene.sphere)
    return _internal_add_sphere();
  }
  inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Sphere> &
  Scene::sphere() const {
    // @@protoc_insertion_point(field_list:tracerr.Scene.sphere)
    return sphere_;
  }

  // repeated .tracerr.Scene.Triangle triangle = 8;
  inline int Scene::_internal_triangle_size() const {
    return triangle_.size();
  }
  inline int Scene::triangle_size() const {
    return _internal_triangle_size();
  }
  inline void Scene::clear_triangle() {
    triangle_.Clear();
  }
  inline ::tracerr::Scene_Triangle *Scene::mutable_triangle(int index) {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.triangle)
    return triangle_.Mutable(index);
  }
  inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Triangle> *
  Scene::mutable_triangle() {
    // @@protoc_insertion_point(field_mutable_list:tracerr.Scene.triangle)
    return &triangle_;
  }
  inline const ::tracerr::Scene_Triangle &Scene::_internal_triangle(int index) const {
    return triangle_.Get(index);
  }
  inline const ::tracerr::Scene_Triangle &Scene::triangle(int index) const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.triangle)
    return _internal_triangle(index);
  }
  inline ::tracerr::Scene_Triangle *Scene::_internal_add_triangle() {
    return triangle_.Add();
  }
  inline ::tracerr::Scene_Triangle *Scene::add_triangle() {
    // @@protoc_insertion_point(field_add:tracerr.Scene.triangle)
    return _internal_add_triangle();
  }
  inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Triangle> &
  Scene::triangle() const {
    // @@protoc_insertion_point(field_list:tracerr.Scene.triangle)
    return triangle_;
  }

  // repeated .tracerr.Scene.Rectangle rectangle = 9;
  inline int Scene::_internal_rectangle_size() const {
    return rectangle_.size();
  }
  inline int Scene::rectangle_size() const {
    return _internal_rectangle_size();
  }
  inline void Scene::clear_rectangle() {
    rectangle_.Clear();
  }
  inline ::tracerr::Scene_Rectangle *Scene::mutable_rectangle(int index) {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.rectangle)
    return rectangle_.Mutable(index);
  }
  inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Rectangle> *
  Scene::mutable_rectangle() {
    // @@protoc_insertion_point(field_mutable_list:tracerr.Scene.rectangle)
    return &rectangle_;
  }
  inline const ::tracerr::Scene_Rectangle &Scene::_internal_rectangle(int index) const {
    return rectangle_.Get(index);
  }
  inline const ::tracerr::Scene_Rectangle &Scene::rectangle(int index) const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.rectangle)
    return _internal_rectangle(index);
  }
  inline ::tracerr::Scene_Rectangle *Scene::_internal_add_rectangle() {
    return rectangle_.Add();
  }
  inline ::tracerr::Scene_Rectangle *Scene::add_rectangle() {
    // @@protoc_insertion_point(field_add:tracerr.Scene.rectangle)
    return _internal_add_rectangle();
  }
  inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Rectangle> &
  Scene::rectangle() const {
    // @@protoc_insertion_point(field_list:tracerr.Scene.rectangle)
    return rectangle_;
  }

  // repeated .tracerr.Scene.Obj obj = 10;
  inline int Scene::_internal_obj_size() const {
    return obj_.size();
  }
  inline int Scene::obj_size() const {
    return _internal_obj_size();
  }
  inline void Scene::clear_obj() {
    obj_.Clear();
  }
  inline ::tracerr::Scene_Obj *Scene::mutable_obj(int index) {
    // @@protoc_insertion_point(field_mutable:tracerr.Scene.obj)
    return obj_.Mutable(index);
  }
  inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Obj> *
  Scene::mutable_obj() {
    // @@protoc_insertion_point(field_mutable_list:tracerr.Scene.obj)
    return &obj_;
  }
  inline const ::tracerr::Scene_Obj &Scene::_internal_obj(int index) const {
    return obj_.Get(index);
  }
  inline const ::tracerr::Scene_Obj &Scene::obj(int index) const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.obj)
    return _internal_obj(index);
  }
  inline ::tracerr::Scene_Obj *Scene::_internal_add_obj() {
    return obj_.Add();
  }
  inline ::tracerr::Scene_Obj *Scene::add_obj() {
    // @@protoc_insertion_point(field_add:tracerr.Scene.obj)
    return _internal_add_obj();
  }
  inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tracerr::Scene_Obj> &
  Scene::obj() const {
    // @@protoc_insertion_point(field_list:tracerr.Scene.obj)
    return obj_;
  }

  // optional bool show_elapsed_time = 11 [default = true];
  inline bool Scene::_internal_has_show_elapsed_time() const {
    bool value = (_has_bits_[0] & 0x00000020u) != 0;
    return value;
  }
  inline bool Scene::has_show_elapsed_time() const {
    return _internal_has_show_elapsed_time();
  }
  inline void Scene::clear_show_elapsed_time() {
    show_elapsed_time_ = true;
    _has_bits_[0] &= ~0x00000020u;
  }
  inline bool Scene::_internal_show_elapsed_time() const {
    return show_elapsed_time_;
  }
  inline bool Scene::show_elapsed_time() const {
    // @@protoc_insertion_point(field_get:tracerr.Scene.show_elapsed_time)
    return _internal_show_elapsed_time();
  }
  inline void Scene::_internal_set_show_elapsed_time(bool value) {
    _has_bits_[0] |= 0x00000020u;
    show_elapsed_time_ = value;
  }
  inline void Scene::set_show_elapsed_time(bool value) {
    _internal_set_show_elapsed_time(value);
    // @@protoc_insertion_point(field_set:tracerr.Scene.show_elapsed_time)
  }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif// __GNUC__
  // -------------------------------------------------------------------

  // -------------------------------------------------------------------

  // -------------------------------------------------------------------

  // -------------------------------------------------------------------

  // -------------------------------------------------------------------

  // -------------------------------------------------------------------


  // @@protoc_insertion_point(namespace_scope)

}// namespace tracerr

PROTOBUF_NAMESPACE_OPEN

template<>
struct is_proto_enum<::tracerr::Scene_ShapeType> : ::std::true_type {};
template<>
inline const EnumDescriptor *GetEnumDescriptor<::tracerr::Scene_ShapeType>() {
  return ::tracerr::Scene_ShapeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif// GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scene_2eproto
